You are a senior React + Vite SSR migration assistant.  
Migrate an existing React CSR app (Vite + React 18) to SSR **inside the same repository** without breaking the current CSR build. Work **incrementally** in a new folder so we can switch back and forth. Use **TypeScript**.

#### Current app (do not break):
- Tooling: Vite ^4.4, React 18, react-router-dom ^6.16, Tailwind, i18next, framer-motion, leaflet/react-leaflet.
- `package.json` (excerpt):
  - scripts:  
    - `"dev": "vite"`  
    - `"build": "tsc && vite build"`  
    - `"preview": "vite preview"`
  - `"type": "module"`

#### Goal
Create a **parallel SSR implementation** that renders the same routes/UI as the CSR app and hydrates on the client. Keep the existing CSR flow intact.

#### High-level plan
1. Create a new folder: `src/ssr/`.
2. Introduce three SSR entry points:
   - `src/ssr/entry-client.tsx` (hydration)
   - `src/ssr/entry-server.tsx` (HTML + app render to string)
   - `src/ssr/server.ts` (Express + Vite dev middleware; static serve in prod)
3. Extract the current routing into a **shared route config** that can be used both by BrowserRouter (CSR) and StaticRouter (SSR). Create `src/routes.tsx`.
4. Keep the current CSR `src/main.tsx` working. Do **not** delete or rewrite the CSR entries.
5. Add robust SSR guards for libraries that require `window`/DOM (e.g., Leaflet/react-leaflet), using dynamic `lazy()` imports and `typeof window !== 'undefined'` checks. Provide placeholders on the server render.
6. Make i18n render safely on the server (no hard dependency on `window`), and fall back gracefully if server-side loading is not yet wired.
7. Add NPM scripts for dev/build/preview SSR that **do not** affect the existing CSR scripts.

#### Dependencies to add
- Runtime: `express`, `compression`, `sirv`  
- Types: `@types/express`  
- Dev convenience: `tsx` (or `ts-node`), `@types/node`  
(Keep existing deps intact. Do not upgrade React/Vite unless strictly required.)

#### File changes

**A) Shared routes**
- Create `src/routes.tsx` that exports a `createAppRoutes()` function returning the route tree using React Router v6 APIs (`createRoutesFromElements` or `createBrowserRouter`/data routers if already used).
- Ensure data loaders (if any) can be executed on the server (optional first pass: keep UI parity; wire loaders later).

**B) Client hydration entry (`src/ssr/entry-client.tsx`)**
- Mount the app with `hydrateRoot` using `BrowserRouter`.
- Example shape:
  ```tsx
  import { hydrateRoot } from 'react-dom/client';
  import { BrowserRouter } from 'react-router-dom';
  import App from '../App'; // or a Root component that consumes routes
  import './styles.css';

  hydrateRoot(
    document.getElementById('root')!,
    <BrowserRouter>
      <App />
    </BrowserRouter>
  );
  ```
- If the current app already has an `App` wrapper, reuse it to avoid duplication.

**C) Server render entry (`src/ssr/entry-server.tsx`)**
- Export an async `render(url, context, manifest?)` that returns `{ html, head?, css? }`.
- Use `StaticRouter` (or `StaticRouterProvider` for data routers) with the shared routes.
- Do not access `window`/`document`. Guard DOM-only code.
- Inject i18n language from `Accept-Language` if easy; otherwise default locale.

**D) HTML template**
- Create `src/ssr/index.html` with a root `<div id="root"></div>` and placeholders for SSR-injected HTML and client scripts.
- In dev: let Vite transform this template.
- In prod: use the built `dist/client` + `dist-ssr/entry-server.js`.

**E) Dev/Prod server (`src/ssr/server.ts`)**
- In **development**:
  - Create an Express server that mounts Vite dev middleware (`createServer({ server: { middlewareMode: true }, appType: 'custom' })`).
  - For all `*` routes, load the SSR module via `vite.ssrLoadModule('/src/ssr/entry-server.tsx')`, call `render(req.originalUrl)`, inject into HTML template via `vite.transformIndexHtml`.
- In **production**:
  - Serve `dist/client` with `sirv`.
  - Import `dist-ssr/entry-server.js` and call `render` per request.
  - Use `compression()`.

**F) Leaflet / react-leaflet SSR safety**
- Wrap any map components so they render **only on client**:
  - Create `src/ssr/ClientOnly.tsx`:
    ```tsx
    import { useEffect, useState } from 'react';
    export default function ClientOnly({ children }: { children: React.ReactNode }) {
      const [mounted, setMounted] = useState(false);
      useEffect(() => setMounted(true), []);
      return mounted ? <>{children}</> : null;
    }
    ```
  - In map pages:
    ```tsx
    import { lazy, Suspense } from 'react';
    import ClientOnly from '../ssr/ClientOnly';
    const Map = lazy(() => import('../components/Map')); // the react-leaflet component

    // Server: renders nothing; Client: hydrates map.
    <ClientOnly>
      <Suspense fallback={<div style={{height: 300}}>Loading map…</div>}>
        <Map />
      </Suspense>
    </ClientOnly>
    ```
- Ensure any direct `window` usage is guarded:
  ```ts
  const isBrowser = typeof window !== 'undefined';
  ```

**G) i18n minimal SSR compatibility**
- Ensure `i18next` init does not crash on server.
- If current init relies on `window` or `localStorage`, check guards.
- Optional: read language from `req.headers['accept-language']?.split(',')[0]` and pass as prop/context; hydrate with same lng client-side to avoid mismatch.

**H) Tailwind**
- Keep current PostCSS/Tailwind setup working for both CSR and SSR.
- Ensure the template `index.html` includes the same CSS entry (via Vite).

#### Package scripts (add, do not remove current ones)
```json
{
  "scripts": {
    "dev:ssr": "NODE_ENV=development tsx src/ssr/server.ts",
    "build:ssr": "tsc && vite build && vite build --ssr src/ssr/entry-server.tsx",
    "preview:ssr": "NODE_ENV=production node dist-ssr/server.js"
  }
}
```

#### Build output assumptions
- Client build: `dist/` (default Vite).
- SSR build: `dist-ssr/entry-server.js`.
- `src/ssr/server.ts` should, on prod, import the SSR build from `dist-ssr/entry-server.js`.

#### Acceptance criteria
- `npm run dev` → current CSR works unchanged.
- `npm run dev:ssr` → dev server SSR renders HTML on first paint and hydrates without console errors.
- `npm run build:ssr && npm run preview:ssr` → serves the SSR build in production mode.
- Navigating all existing routes shows identical UI/behavior to CSR (except that SSR-only placeholders may be used for DOM-only widgets until hydrated).
- No crashes on server due to `window`/`document`.
- Leaflet/react-leaflet load only on client; server output renders a safe placeholder.
- i18n: server and client render consistent language to avoid hydration mismatch (basic locale OK).

#### Implementation details to generate
- Full code for:
  - `src/routes.tsx` (shared routes)
  - `src/ssr/entry-client.tsx`
  - `src/ssr/entry-server.tsx` (with `render(url)` that returns full HTML snippet for `#root`)
  - `src/ssr/index.html` (template with `<!--app-html-->` and `<!--ssr-head-->` markers)
  - `src/ssr/server.ts` (Express + Vite in dev; static + SSR in prod)
  - `src/ssr/ClientOnly.tsx`
- Minimal i18n-safe init that doesn’t break SSR (guards around browser-only APIs).
- Examples showing how to wrap any map component (Leaflet) and any other DOM-dependent code.

#### Guardrails
- Do not refactor unrelated code.
- Do not remove current scripts or change `type: "module"`.
- Keep React 18; use `renderToPipeableStream` or `renderToString`—choose the simplest reliable approach; prioritize correctness and parity.
- Keep Tailwind exactly as configured.

When done, output the diff of new/changed files and any instructions needed to run `dev:ssr`, `build:ssr`, and `preview:ssr`.
